package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"path"
	"strings"
	"time"
	"unicode"

	"github.com/BurntSushi/toml"
)

// Keyword Response types
const (
	Redirect = iota
	Render
)

const (
	aliasLimit = 10
)

var (
	defaultTimeout = 5 * time.Second
	defaultURL     = "https://encrypted.google.com/search?q="
	types          = map[string]int{"redirect": Redirect, "render": Render}
	static         = map[string]func() []byte{}

	errNoURL           = errors.New("keyfu: no url")
	errNoQueryURL      = errors.New("keyfu: no query url")
	errParse           = errors.New("keyfu: parse error")
	errLinkConfig      = errors.New("keyfu: invalid link keyword")
	errProgramName     = errors.New("keyfu: program name invalid")
	errProgramResponse = errors.New("keyfu: program response invalid")
	errProgramTimeout  = errors.New("keyfu: program timed out")
)

// Config holds server configuration data, loaded from the toml
// configuration file.
type Config struct {
	Listen   string                       `toml:"listen"`
	Keywords map[string]map[string]string `toml:"keyword"`
}

// Response is the redirect/render action generated by keyword
// Run function.
type Response struct {
	Type int
	Body string
}

// Keyword is the interface that all keywords must implement.
type Keyword interface {
	Run(r *Request) (*Response, error)
}

// parse takes a string in the form "keyword [query]" and returns the parsed
// key/value pair or an error.
func parse(v string) (string, string, error) {
	if v == "" {
		return "", "", errParse
	}

	begin := -1
	end := len(v)
	for i, r := range v {
		if !unicode.IsSpace(r) {
			if begin == -1 {
				begin = i
			}
		} else if begin != -1 {
			end = i
			break
		}
	}

	if begin == -1 {
		return "", "", errParse
	}

	return v[begin:end], strings.TrimLeftFunc(v[end:], unicode.IsSpace), nil
}

// LinkKeyword is a simple Keyword implementation that uses a direct and
// query URL to return a redirect response.
type LinkKeyword struct {
	URL      string
	QueryURL string
}

// NewLinkKeyword returns a LinkKeyword from a string map parsed from
// toml configuration file.
func NewLinkKeyword(c map[string]string) (*LinkKeyword, error) {
	k := LinkKeyword{c["url"], c["query_url"]}
	if k.URL == "" && k.QueryURL == "" {
		return nil, errLinkConfig
	}
	return &k, nil
}

// Run accepts a Request and returns a redirect response based on the
// URL/QueryURL configuration and query.
func (k LinkKeyword) Run(req *Request) (*Response, error) {
	var u string

	if len(req.Value) > 0 {
		if len(k.QueryURL) == 0 {
			return nil, errNoQueryURL
		}
		u = k.QueryURL
	} else {
		if len(k.URL) == 0 {
			return nil, errNoURL
		}
		u = k.URL
	}

	return &Response{Redirect, strings.Replace(u, "%s", url.QueryEscape(req.Value), -1)}, nil
}

// ProgramKeyword is a Keyword implementation that uses an external program
// to evaluate a run.
type ProgramKeyword struct {
	Name    string
	Timeout time.Duration
}

// NewProgramKeyword returns a ProgramKeyword from a string map parsed from
// toml configuration file.
func NewProgramKeyword(c map[string]string) (*ProgramKeyword, error) {
	k := ProgramKeyword{}

	if name, ok := c["name"]; ok && len(name) > 0 {
		k.Name = name
	} else {
		return nil, errProgramName
	}

	if timeout, ok := c["timeout"]; ok {
		t, err := time.ParseDuration(timeout)
		if err != nil {
			return nil, err
		}
		k.Timeout = t
	} else {
		k.Timeout = defaultTimeout
	}

	return &k, nil
}

// Run accepts a request, spawns a subprocess, and parses the process output
// to create and return a response.
//
// So if the name parameter was set to "example" and the user query was
// "mytest hello world" then the following would be executed.
//
//   example "mytest hello world" "mytest" "hello world"
//
// And would expect the response in one of the following formats:
//
//   redirect\thttp://www.example.org/
//   render\thello world
func (r ProgramKeyword) Run(req *Request) (*Response, error) {
	cmd := exec.Command(r.Name, req.Query, req.Key, req.Value)
	cmd.Env = []string{}

	var out bytes.Buffer
	cmd.Stdout = &out

	err := cmd.Start()
	if err != nil {
		return nil, err
	}

	done := make(chan error)

	go func() {
		done <- cmd.Wait()
	}()

	select {
	case <-time.After(r.Timeout):
		if err := cmd.Process.Kill(); err != nil {
			return nil, err
		}
		cmd.Wait()
		<-done
		return nil, errProgramTimeout
	case err := <-done:
		if err != nil {
			return nil, err
		}
	}

	c, b, err := parse(out.String())
	if err != nil {
		return nil, err
	}

	var res Response

	var ok bool
	if res.Type, ok = types[c]; !ok {
		return nil, errProgramResponse
	}

	if res.Type == Redirect {
		b = strings.TrimSpace(b)
	}

	res.Body = b

	return &res, nil
}

// Request represents the run request.
type Request struct {
	Query string
	Key   string
	Value string
}

// NewRequest parses and returns a new request.
func NewRequest(q string) (*Request, error) {
	r := new(Request)

	if err := r.Parse(q); err != nil {
		return nil, err
	}

	return r, nil
}

// Parse splits a query into a keyword and a value. So for the query
// "example one two" it parses "example one two" into Query, "example"
// into Key, and "one two" into Value.
func (r *Request) Parse(q string) (err error) {
	r.Query = q
	r.Key, r.Value, err = parse(q)
	return
}

// Server holds the application state.
type Server struct {
	Config    Config
	Keywords  map[string]Keyword
	StartTime time.Time
}

// RunError logs any errors and does a redirect to the default query URL.
func (s *Server) RunError(w http.ResponseWriter, r *http.Request, err error) {
	if err != nil {
		log.Print(err)
	}
	q := r.FormValue("q")
	http.Redirect(w, r, defaultURL+url.QueryEscape(q), 302)
}

// RunHandler gets the query, looks up the keyword, and handles whatever
// response is returned by the Keyword run method.
func (s *Server) RunHandler(w http.ResponseWriter, r *http.Request) {
	req, err := NewRequest(r.FormValue("q"))
	if err != nil {
		s.RunError(w, r, err)
		return
	}

	k, ok := s.Keywords[req.Key]
	if !ok {
		s.RunError(w, r, nil)
		return
	}

	res, err := k.Run(req)
	if err != nil {
		s.RunError(w, r, err)
		return
	}

	if res.Type == Redirect {
		http.Redirect(w, r, res.Body, 302)
	} else {
		io.WriteString(w, res.Body)
	}
}

// StaticHandler serves embeded static content.
func (s *Server) StaticHandler(w http.ResponseWriter, r *http.Request) {
	p := r.URL.Path
	if p[len(p)-1] == '/' {
		p = p + "index.html"
	}
	b, found := static["/static"+p]
	if !found {
		http.NotFound(w, r)
		return
	}
	_, name := path.Split(p)
	http.ServeContent(w, r, name, s.StartTime, bytes.NewReader(b()))
}

func (s *Server) newKeyword(k string, c int) (keyword Keyword, err error) {
	if c > aliasLimit {
		return nil, fmt.Errorf("keyfu: keyword alias exceeds %d limit: %s", aliasLimit, k)
	}

	v, ok := s.Config.Keywords[k]
	if !ok {
		return nil, fmt.Errorf("keyfu: keyword unknown: %s", k)
	}

	switch v["type"] {
	case "alias":
		return s.newKeyword(v["name"], c+1)
	case "link", "":
		return NewLinkKeyword(v)
	case "program":
		return NewProgramKeyword(v)
	default:
		return nil, fmt.Errorf("keyword unknown type: %s (%s)", k, v["type"])
	}
}

// Load gets keywords from configuration and loads them into
// server state.
func (s *Server) Load() {
	s.Keywords = map[string]Keyword{}

	for k := range s.Config.Keywords {
		if keyword, err := s.newKeyword(k, 0); err == nil {
			s.Keywords[k] = keyword
		} else {
			log.Printf(err.Error())
		}
	}
}

// Init reads configuration and sets up server state.
func (s *Server) Init(path string) error {
	if _, err := toml.DecodeFile(path, &s.Config); err != nil {
		return err
	}

	s.StartTime = time.Now()

	if s.Config.Listen == "" {
		host := os.Getenv("HOST")
		port := os.Getenv("PORT")

		if port == "" {
			port = "8000"
		}

		s.Config.Listen = host + ":" + port
	}

	s.Load()

	return nil
}

// Run starts HTTP server.
func (s *Server) Run() {
	http.HandleFunc("/run", s.RunHandler)

	if len(static) > 0 {
		http.HandleFunc("/", s.StaticHandler)
	} else {
		http.Handle("/", http.FileServer(http.Dir("./static/")))
	}

	log.Fatal(http.ListenAndServe(s.Config.Listen, nil))
}

func main() {
	var path = flag.String("c", "keyfu.conf", "KeyFu configuration file")
	flag.Parse()

	s := Server{}

	if err := s.Init(*path); err != nil {
		log.Fatal(err.Error())
	}

	s.Run()
}
