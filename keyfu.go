package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"io"
	"log"
	"net"
	"net/http"
	"net/url"
	"os"
	"path"
	"strings"
	"time"
	"unicode"

	"github.com/BurntSushi/toml"
)

// Keyword Response types
const (
	Redirect = iota
	Serve
)

const (
	aliasLimit = 10
)

var (
	defaultTimeout = 5 * time.Second
	defaultURL     = "https://encrypted.google.com/search?q="
	types          = map[string]int{"redirect": Redirect, "serve": Serve}

	errNoURL      = errors.New("keyfu: no url")
	errNoQueryURL = errors.New("keyfu: no query url")
	errParse      = errors.New("keyfu: parse error")
	errLinkConfig = errors.New("keyfu: invalid link keyword")
)

// Config holds server configuration data, loaded from the toml
// configuration file.
type Config struct {
	Listen   string                       `toml:"listen"`
	URL      string                       `toml:"url"`
	Keywords map[string]map[string]string `toml:"keyword"`
}

// Response is the redirect/serve action generated by keyword
// Run function.
type Response struct {
	Type int
	Body string
}

// Keyword is the interface that all keywords must implement.
type Keyword interface {
	Run(r *Request) (*Response, error)
}

// parse takes a string in the form "keyword [query]" and returns the parsed
// key/value pair or an error.
func parse(v string) (string, string, error) {
	if v == "" {
		return "", "", errParse
	}

	begin := -1
	end := len(v)
	for i, r := range v {
		if !unicode.IsSpace(r) {
			if begin == -1 {
				begin = i
			}
		} else if begin != -1 {
			end = i
			break
		}
	}

	if begin == -1 {
		return "", "", errParse
	}

	return v[begin:end], strings.TrimLeftFunc(v[end:], unicode.IsSpace), nil
}

// LinkKeyword is a simple Keyword implementation that uses a direct and
// query URL to return a redirect response.
type LinkKeyword struct {
	URL      string
	QueryURL string
}

// NewLinkKeyword returns a LinkKeyword from a string map parsed from
// toml configuration file.
func NewLinkKeyword(c map[string]string) (*LinkKeyword, error) {
	k := LinkKeyword{c["url"], c["query_url"]}
	if k.URL == "" && k.QueryURL == "" {
		return nil, errLinkConfig
	}
	return &k, nil
}

// Run accepts a Request and returns a redirect response based on the
// URL/QueryURL configuration and query.
func (k LinkKeyword) Run(req *Request) (*Response, error) {
	var u string

	if len(req.Value) > 0 {
		if len(k.QueryURL) == 0 {
			return nil, errNoQueryURL
		}
		u = k.QueryURL
	} else {
		if len(k.URL) == 0 {
			return nil, errNoURL
		}
		u = k.URL
	}

	return &Response{Redirect, strings.Replace(u, "%s", url.QueryEscape(req.Value), -1)}, nil
}

// Request represents the run request.
type Request struct {
	Query string
	Key   string
	Value string
}

// NewRequest parses and returns a new request.
func NewRequest(q string) (*Request, error) {
	r := new(Request)

	if err := r.Parse(q); err != nil {
		return nil, err
	}

	return r, nil
}

// Parse splits a query into a keyword and a value. So for the query
// "example one two" it parses "example one two" into Query, "example"
// into Key, and "one two" into Value.
func (r *Request) Parse(q string) (err error) {
	r.Query = q
	r.Key, r.Value, err = parse(q)
	return
}

// Server holds the application state.
type Server struct {
	Config    Config
	Keywords  map[string]Keyword
	StartTime time.Time
}

// RunError logs any errors and does a redirect to the default query URL.
func (s *Server) RunError(w http.ResponseWriter, r *http.Request, err error) {
	if err != nil {
		log.Print(err)
	}
	q := r.FormValue("q")
	http.Redirect(w, r, defaultURL+url.QueryEscape(q), 302)
}

// RunHandler gets the query, looks up the keyword, and handles whatever
// response is returned by the Keyword run method.
func (s *Server) RunHandler(w http.ResponseWriter, r *http.Request) {
	req, err := NewRequest(r.FormValue("q"))
	if err != nil {
		s.RunError(w, r, err)
		return
	}

	k, ok := s.Keywords[req.Key]
	if !ok {
		s.RunError(w, r, nil)
		return
	}

	res, err := k.Run(req)
	if err != nil {
		s.RunError(w, r, err)
		return
	}

	if res.Type == Redirect {
		http.Redirect(w, r, res.Body, 302)
	} else {
		io.WriteString(w, res.Body)
	}
}

func (s *Server) OpenSearchHandler(w http.ResponseWriter, r *http.Request) {
	if b, err := Asset("static/opensearch.xml"); err == nil {
		w.Write(bytes.Replace(b, []byte("http://www.keyfu.com"), []byte(s.Config.URL), 1))
	} else {
		http.NotFound(w, r)
	}
}

// StaticHandler serves embeded static content.
func (s *Server) StaticHandler(w http.ResponseWriter, r *http.Request) {
	p := r.URL.Path

	if p[len(p)-1] == '/' {
		p = p + "index.html"
	}

	b, err := Asset("static" + p)
	if err != nil {
		http.NotFound(w, r)
		return
	}

	_, name := path.Split(p)

	http.ServeContent(w, r, name, s.StartTime, bytes.NewReader(b))
}

func (s *Server) newKeyword(k string, c int) (keyword Keyword, err error) {
	if c > aliasLimit {
		return nil, fmt.Errorf("keyfu: keyword alias exceeds %d limit: %s", aliasLimit, k)
	}

	v, ok := s.Config.Keywords[k]
	if !ok {
		return nil, fmt.Errorf("keyfu: keyword unknown: %s", k)
	}

	switch v["type"] {
	case "alias":
		return s.newKeyword(v["name"], c+1)
	case "link", "":
		return NewLinkKeyword(v)
	default:
		return nil, fmt.Errorf("keyword unknown type: %s (%s)", k, v["type"])
	}
}

// Load gets keywords from configuration and loads them into
// server state.
func (s *Server) Load() {
	s.Keywords = map[string]Keyword{}

	for k := range s.Config.Keywords {
		if keyword, err := s.newKeyword(k, 0); err == nil {
			s.Keywords[k] = keyword
		} else {
			log.Printf(err.Error())
		}
	}
}

// Init reads configuration and sets up server state.
func (s *Server) Init(path string) error {
	if _, err := toml.DecodeFile(path, &s.Config); err != nil {
		return err
	}

	s.StartTime = time.Now()

	if s.Config.Listen == "" {
		host := os.Getenv("HOST")
		port := os.Getenv("PORT")

		if port == "" {
			port = "8000"
		}

		s.Config.Listen = net.JoinHostPort(host, port)
	}

	if s.Config.URL == "" {
		host, port, err := net.SplitHostPort(s.Config.Listen)
		if err != nil {
			return err
		}
		if host == "" {
			host = "localhost"
		}
		s.Config.URL = fmt.Sprintf("http://%s:%s", host, port)
	}

	s.Load()

	return nil
}

// Run starts HTTP server.
func (s *Server) Run() {
	http.HandleFunc("/run", s.RunHandler)
	http.HandleFunc("/opensearch.xml", s.OpenSearchHandler)
	http.HandleFunc("/", s.StaticHandler)

	log.Fatal(http.ListenAndServe(s.Config.Listen, nil))
}

func main() {
	var path = flag.String("c", "keyfu.conf", "KeyFu configuration file")
	flag.Parse()

	s := Server{}

	if err := s.Init(*path); err != nil {
		log.Fatal(err.Error())
	}

	s.Run()
}
